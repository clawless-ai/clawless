"""Skill Proposer â€” generates new skill code and writes it to the proposals directory.

The proposer is itself a skill. It:
1. Detects requests like "create a skill to..." or "learn how to..."
2. Asks the LLM to generate a complete BaseSkill subclass
3. Runs static analysis on the generated code (forbidden imports, builtins)
4. Writes the proposal to /data/proposals/ with warnings if any
5. A human must manually review, copy to skills/enabled/, and restart
"""

from __future__ import annotations

import ast
import logging
import re
import textwrap
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

from clawless.skills.base import BaseSkill
from clawless.types import Message, Session, SkillResult
from clawless.utils.helpers import ensure_proposals_dir, safe_write_file

logger = logging.getLogger(__name__)

# Modules that proposed skills must NOT import
FORBIDDEN_IMPORTS = frozenset({
    "os", "sys", "subprocess", "shutil", "socket", "http",
    "urllib", "requests", "httpx", "importlib", "ctypes",
    "multiprocessing", "threading", "signal", "pathlib",
    "tempfile", "glob", "fnmatch", "io", "pickle", "shelve",
    "marshal", "code", "codeop", "compileall", "py_compile",
})

# Built-in functions/names that proposed skills must NOT use
FORBIDDEN_BUILTINS = frozenset({
    "eval", "exec", "compile", "__import__", "open",
    "globals", "locals", "vars", "dir", "getattr", "setattr", "delattr",
    "breakpoint", "exit", "quit",
})

# Template that the LLM should fill in
SKILL_TEMPLATE = textwrap.dedent("""\
    \"\"\"Auto-generated skill proposal: {name}

    Description: {description}
    Generated: {timestamp}

    WARNINGS:
    {warnings}

    REVIEW REQUIRED: A human must review this file before activation.
    To activate: copy to skills/enabled/ and add to skills_manifest.yaml, then restart.
    \"\"\"

    from clawless.skills.base import BaseSkill, BaseTool
    from clawless.types import Message, Session, SkillResult

    {body}
""")

GENERATION_PROMPT = textwrap.dedent("""\
    Generate a complete Python skill class for the Clawless agent framework.

    The skill must:
    - Subclass BaseSkill (from clawless.skills.base)
    - Implement: name (property), description (property), trigger_phrases (property), handle(session, message) -> SkillResult | None
    - Only import from: clawless.skills.base, clawless.types
    - NOT use: os, subprocess, eval, exec, open, or any system-level operations
    - Return a SkillResult with success=True/False and output string

    User request: {request}

    Respond with ONLY the Python class code (no markdown, no explanation).
""")


class SkillProposer(BaseSkill):
    """Built-in skill that generates new skill proposals."""

    def __init__(self, data_dir: Path | None = None) -> None:
        self._data_dir = data_dir

    @property
    def name(self) -> str:
        return "skill_proposer"

    @property
    def description(self) -> str:
        return "Generates new skill proposals from user descriptions. Proposals require human review."

    @property
    def trigger_phrases(self) -> list[str]:
        return ["create a skill", "learn how to", "make a skill", "new skill"]

    def handle(self, session: Session, message: Message) -> SkillResult | None:
        # This skill requires an LLM to generate code.
        # The agent loop should call propose() with the LLM response.
        # handle() just signals that this skill was triggered.
        return SkillResult(
            success=True,
            output="I can create a skill proposal for that. Let me generate the code.",
            data={"action": "propose", "request": message.content},
        )

    def propose(self, skill_description: str, generated_code: str, data_dir: Path) -> SkillResult:
        """Process LLM-generated skill code: analyze, wrap, and write to proposals.

        Args:
            skill_description: The user's original request.
            generated_code: The Python code generated by the LLM.
            data_dir: The root data directory.

        Returns:
            SkillResult indicating success/failure and the file path.
        """
        # Run static analysis
        warnings = analyze_code_safety(generated_code)

        # Generate a safe filename
        safe_name = _sanitize_name(skill_description)
        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
        filename = f"proposed_{safe_name}_{timestamp}.py"

        # Format the warnings section
        if warnings:
            warnings_text = "\n    ".join(f"- {w}" for w in warnings)
            warnings_text = "SAFETY ISSUES DETECTED:\n    " + warnings_text
        else:
            warnings_text = "No safety issues detected by static analysis."

        # Build the full file
        file_content = SKILL_TEMPLATE.format(
            name=safe_name,
            description=skill_description,
            timestamp=timestamp,
            warnings=warnings_text,
            body=generated_code,
        )

        # Write to proposals directory
        ensure_proposals_dir(data_dir)
        relative_path = f"proposals/{filename}"
        written_path = safe_write_file(data_dir, relative_path, file_content)

        status = "with warnings" if warnings else "clean"
        return SkillResult(
            success=True,
            output=f"Skill proposal written to {written_path} ({status}). "
            f"A human must review and approve before activation.",
            data={"path": str(written_path), "warnings": warnings},
        )


def analyze_code_safety(code: str) -> list[str]:
    """Static analysis of generated Python code for forbidden patterns.

    Returns a list of warning strings. Empty list means no issues found.
    """
    warnings: list[str] = []

    # Try to parse the AST
    try:
        tree = ast.parse(code)
    except SyntaxError as e:
        return [f"Syntax error in generated code: {e}"]

    for node in ast.walk(tree):
        # Check imports
        if isinstance(node, ast.Import):
            for alias in node.names:
                top_module = alias.name.split(".")[0]
                if top_module in FORBIDDEN_IMPORTS:
                    warnings.append(f"Forbidden import: '{alias.name}' (line {node.lineno})")

        elif isinstance(node, ast.ImportFrom):
            if node.module:
                top_module = node.module.split(".")[0]
                if top_module in FORBIDDEN_IMPORTS:
                    warnings.append(
                        f"Forbidden import from: '{node.module}' (line {node.lineno})"
                    )

        # Check forbidden builtin calls
        elif isinstance(node, ast.Call):
            func_name = _get_call_name(node)
            if func_name in FORBIDDEN_BUILTINS:
                warnings.append(f"Forbidden builtin call: '{func_name}' (line {node.lineno})")

        # Check string-based dynamic execution patterns
        elif isinstance(node, ast.Constant) and isinstance(node.value, str):
            val = node.value
            if any(pattern in val for pattern in ("__import__", "eval(", "exec(")):
                warnings.append(
                    f"Suspicious string containing code execution pattern (line {node.lineno})"
                )

    return warnings


def _get_call_name(node: ast.Call) -> str:
    """Extract the function name from a Call node."""
    if isinstance(node.func, ast.Name):
        return node.func.id
    if isinstance(node.func, ast.Attribute):
        return node.func.attr
    return ""


def _sanitize_name(description: str) -> str:
    """Convert a description into a safe filename component."""
    # Take first few words, lowercase, replace non-alphanum with underscores
    words = description.lower().split()[:4]
    name = "_".join(words)
    name = re.sub(r"[^a-z0-9_]", "", name)
    return name[:50] or "unnamed"
